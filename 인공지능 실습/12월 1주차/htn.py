# -*- coding: utf-8 -*-
"""HTN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iocCXUbdIl6gHr8T--gC3jipQSjDYW6J
"""

import copy, sys

class State():
  def __init__(self, name):
    self.__name__ = name

# 상태(state)와 목표(goal)  
class Goal():
  def __init__(self, name):
    self.__name__ = name

# 상태와 목표의 출력
def print_state(state, indent=4): # 상태에 있는 변수들 출력
  if state != False:
    for (name,val) in vars(state).items():
      if name != '__name__':
        for x in range(indent):
          sys.stdout.write(' ')
        sys.stdout.write(state.__name__ + '.' + name)
        print(' =', val)
    else: print('False')

def print_goal(goal, indent=4): # 목표에 있는 변수들 출력
  if goal != False:
    for (name, val) in vars(goal).items():
      if name != '__name__':
        for x in range(indent):
          sys.stdout.write(' ')
        sys.stdout.write(goal.__name__ + '.' + name)
        print(' =', val)
    else: print('False')

# Helper 함수
def forall(seq, cond): # seq에 있는 모든 x에 대해 cond(x)가 만족되면 True
  for x in seq:
    if not cond(x):
      return False
    return True

def find_if(cond, seq): #seq에서 cond(x)를 만족하는 첫번째 x 반환
  for x in seq:
    if cond(x):
      return x
    return None

# 연산자(operator)와 method 등록
operators = {}
methods = {}

def declare_operators(*op_list): # 연산자 정의한 후 호출: op_list는 함수들의 리스트
  operators.update({op.__name__: op for op in op_list})
  return declare_operators

def declare_methods(task_name, *method_list): # 각 task에 대해 한번 호출
  # task_name : 태스크 이름, 문자열, method_list : 함수들의 리스트
  methods.update({task_name: list(method_list)})
  return methods[task_name]

#연산자와 메소드 출력
def pyhop(state, tasks, verbose=0): # 상태 state에서 task를 수행하는 계획 수립
  print('태스크 : ', tasks)
  if verbose>0:
    print('verbose={}:\n상태 = {}\n태스크 = {}'.format(verbose, state.__name__, tasks))
  result = seek_plan(state, tasks, [], 0, verbose)
  if verbose>0:
    print('결과 : ', result, '\n')
  return result

def seek_plan(state, tasks, plan, depth, verbose=0):
  # plan: 현재 부분계획,  depth: recursion depth(디버깅용), verbose: 디버깅 메시지출력
  if verbose > 1:
    print('깊이 {} 태스크 {}'.format(depth, tasks))
  if tasks == []:
    if verbose > 2:
      print('깊이 {} 반환된 계획 {}'.format(depth, plan))
    return plan
  task1 = tasks[0]
  if task1[0] in operators: # 기본 태스크(연산자)인 경우
    if verbose > 2:
      print('깊이 {} 행동 {}'.format(depth, task1))
    operator = operators[task1[0]]
    newstate = operator(copy.deepcopy(state), *task1[1:])
    if verbose > 2:
      print('깊이 {} 새로운 상태:'.format(depth))
      print_state(newstate)
    if newstate:
      solution = seek_plan(newstate, tasks[1:], plan+[task1], depth+1, verbose)
      if solution != False:
        return solution
  if task1[0] in methods: # 복합 태스크(메소드)인 경우
    if verbose > 2:
      print('깊이 {} 메소드 {}'.format(depth, task1))
    relevant = methods[task1[0]] # 부분 태스크
    for method in relevant:
      subtasks = method(state, *task1[1:])
      if verbose > 2:
        print('깊이 {} 새로운 테스크: {}'.format(depth, subtasks))
      if subtasks != False:
        solution = seek_plan(state, subtasks+tasks[1:], plan, depth+1, verbose)
        if solution != False:
          return solution
  if verbose > 2: print('깊이 {} 실패'.format(depth))
  return False
  
def travel_by_foot(state, a, x, y):
  if state.dist[x][y] <= 4:
    return [('walk', a,x,y)]
  return False

def travel_by_taxi(state, a, x, y):
  if state.cash[a] >= 1.5 + 0.5*state.dist[x][y]:
    return [('call_taxi',a,x), ('ride_taxi',a,x,y), ('pay_driver', a)]
  return False

declare_methods('travel', travel_by_foot, travel_by_taxi)

def walk(state, a, x, y):
  if state.loc[a] == x:
    state.loc[a] = y
    return state
  else:
    return False

def call_taxi(state, a, x):
  state.loc['taxi'] = x
  return state

def ride_taxi(state, a, x, y):
  if state.loc['taxi'] == x and state.loc[a] == x:
    state.loc['taxi'] = y
    state.loc[a] = y
    state.owe[a] = 1.5 + 0.5*state.dist[x][y]
    return state
  else:
    return False

def pay_driver(state, a):
  if state.cash[a] >= state.owe[a]:
    state.cash[a] = state.cash[a] - state.owe[a]
    state.owe[a] = 0
    return state
  else:
    return False

declare_operators(walk, call_taxi, ride_taxi, pay_driver)

state1 = State('state1')
state1.loc = {'me':'home'}
state1.cash = {'me':20}
state1.owe = {'me':0}
state1.dist = {'home':{'park':8}, 'park':{'home':8}}

#계획수립기 호출
pyhop(state1, [('travel', 'me', 'home', 'park')], verbose=3)

