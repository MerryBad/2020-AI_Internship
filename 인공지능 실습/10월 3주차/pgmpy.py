# -*- coding: utf-8 -*-
"""pgmpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dqT6g2evU-LbhQaL06dPT4NLxy7jlVw0
"""

!pip install pgmpy

import networkx as nx
from networkx.drawing.nx_pydot import to_pydot
from IPython.core.display import Image

g = nx.DiGraph()

g.add_edge("E","A") # E와 A노드를 생성해서 연결
g.add_edge("B","A") # B와 A노드를 생성해서 연결
g.add_edge("A","N") # A와 N노드를 생성해서 연결

d = to_pydot(g)
d.get_node("N")[0].set_fillcolor("grey")   # N 노드의 색깔 설정
d.get_node("N")[0].set_style("filled")     # N 노드 색 채움
d.set_dpi(300)                   # 해상도
d.set_margin(0.2)                 # 마진 설정
Image(d.create_png(), width=200) # 이미지로 출력

from pgmpy.factors.discrete import TabularCPD
import numpy as np

# 지진(Earthquake) 발생 확률 분포
P_E = TabularCPD('E', 2, [[0.9], [0.1]], state_names={'E': ['F', 'T']})
print('P(E)')
print(P_E)

# 절도(Burglary) 발생 확률분포
P_B = TabularCPD('B', 2, [[0.7], [0.3]], state_names={'B': ['F', 'T']})
print('P(EB')
print(P_B)

# 경보(Alarm) 발생 확률 분포
P_A_I_EB = TabularCPD('A', 2, [[0.99, 0.1, 0.3, 0.01], [0.01, 0.9, 0.7, 0.99]], 
                      evidence=['E', 'B'], evidence_card = [2,2], 
                      state_names={'A': ['F', 'T'], 'E': ['F', 'T'], 'B': ['F', 'T']})
print('P(A|EB)')
print(P_A_I_EB)

# 이웃(Neighbor) 전화 확률 분포
P_N_I_A = TabularCPD('N', 2,
                 np.array([[0.9,  0.2], [0.1, 0.8]]),
                 evidence=['A'], evidence_card=[2],
                 state_names={'N': ['F', 'T'], 'A': ['F','T']})
print('P(N|A)')
print(P_N_I_A)

from pgmpy.models import BayesianModel

# 베이지안 망 구조 정의
model = BayesianModel([('E', 'A'), ('B','A'),('A','N')])
model.add_cpds(P_E, P_B, P_A_I_EB, P_N_I_A) # 확률분포 등록
model.check_model()

from pgmpy.inference import VariableElimination

# 베이지안 망의 추론
infer = VariableElimination(model)
A_dist = infer.query(['A'])
print('P(A)')
print(A_dist)

N_I_EF_BT = infer.query(['N'], evidence={'E':'F', 'B':'T'})
print('P(N | E=F, B=T)')
print(N_I_EF_BT)

N_I_AF_BT = infer.query(['N'], evidence={'A':'F', 'B':'T'})
print('P(N | A=F, B=T)')
print(N_I_AF_BT)

import networkx as nx
from IPython.core.display import Image
from networkx.drawing.nx_pydot import to_pydot

g1 = nx.Graph()
g1.add_edge("A", "B")
g1.add_edge("D", "A")
g1.add_edge("B", "C")
g1.add_edge("C", "D")

d1 = to_pydot(g1)
d1.set_dpi(300)
d1.set_margin(0.5)
Image(d1.create_png(), width=300)

from pgmpy.models import MarkovModel
from pgmpy.factors.discrete import DiscreteFactor

# 마르코프 랜덤 필드(마르코프 모델) 모델 정의
model = MarkovModel([('A', 'B'), ('B', 'C'), ('C','D'), ('D','A')])
factor1 = DiscreteFactor(['A', 'B'], [2,2], [30, 5, 1, 10], state_names={'A': [0,1], 'B':[0,1]})
factor2 = DiscreteFactor(['B', 'C'], [2,2], [100, 1, 1, 100], state_names={'B': [0,1], 'C':[0,1]})
factor3 = DiscreteFactor(['C', 'D'], [2,2], [1, 100, 100, 1], state_names={'C': [0,1], 'D':[0,1]})
factor4 = DiscreteFactor(['D', 'A'], [2,2], [100, 1, 1, 100], state_names={'D': [0,1], 'A':[0,1]})
model.add_factors(factor1, factor2, factor3, factor4)
print('모델의 타당성: ', model.check_model())

import numpy as np
pf_value = model.get_partition_function()
print('\n분할 함수의 값: ', pf_value)

infer = VariableElimination(model) # 추론 객체 생성

phi_ABCD = infer.query(['A', 'B', 'C', 'D'])  # 전체 분포 phi(A,B,C,D)
print('phi(A,B,C,D)')
print(phi_ABCD)
P_ABCD = phi_ABCD.values/pf_value   # 확률 = (팩터의 곱)/(분할 함수의 값)
PABCD = np.reshape(P_ABCD, -1)
for val in PABCD: # 확률의 출력
  print(val, '\n')

A_dist = infer.query(['A'])   # A의 분포 phi(A)
print('phi(A)')
print(A_dist)
P_A = A_dist.values/np.sum(A_dist.values)
for val in P_A:
  print(val, '\n')

AIB0C1_dist = infer.query(['A'], evidence={'B':0, 'C':1})   # phi(A|B=0, C=1)
print('phi(A|B=0, C=1)')
print(AIB0C1_dist)
P_AIB0C1 = AIB0C1_dist.values/np.sum(AIB0C1_dist.values)
for val in P_AIB0C1:
  print(val, '\n')